# Story 8.4: Implement Finding Verifications Table

Status: complete

## Story

As a **developer**,
I want **verification records stored for all findings**,
So that **attorney approvals are tracked for audit and export**.

## Acceptance Criteria

1. **Given** a finding is generated by an engine
   **When** it is created
   **Then** finding_verifications table records: verification_id, matter_id, finding_id, finding_type, finding_summary, verified_by (null), decision (pending)

2. **Given** an attorney verifies a finding
   **When** approval is recorded
   **Then** verified_by, verified_at, decision (approved/rejected/flagged), notes are updated
   **And** confidence_before and confidence_after are recorded

3. **Given** finding confidence is > 90%
   **When** verification requirement is checked
   **Then** verification is optional (informational only)

4. **Given** finding confidence is 70-90%
   **When** verification requirement is checked
   **Then** verification is suggested (badge shown)

5. **Given** finding confidence is < 70%
   **When** verification requirement is checked
   **Then** verification is required before export

## Tasks / Subtasks

- [x] Task 1: Create Database Migration (AC: #1)
  - [x] 1.1: Create `supabase/migrations/20260114000009_create_finding_verifications_table.sql`
  - [x] 1.2: Define `finding_verifications` table with columns: id (uuid), matter_id (uuid FK), finding_id (uuid FK nullable), finding_type (text), finding_summary (text), confidence_before (float), decision (text), verified_by (uuid FK nullable), verified_at (timestamptz), confidence_after (float nullable), notes (text), created_at, updated_at
  - [x] 1.3: Add CHECK constraint for decision: 'pending', 'approved', 'rejected', 'flagged'
  - [x] 1.4: Add CHECK constraint for confidence: 0.0-100.0 (0-100% scale to match existing patterns)
  - [x] 1.5: Create indexes: matter_id, finding_id, decision, verified_by, confidence_before
  - [x] 1.6: Create partial index for pending verifications (verification queue optimization)
  - [x] 1.7: Create composite index for matter + decision filtering

- [x] Task 2: Implement RLS Policies (AC: #1, #2)
  - [x] 2.1: Enable RLS on finding_verifications table
  - [x] 2.2: SELECT policy: Users can view verifications for their matters
  - [x] 2.3: INSERT policy: Editors/Owners can create verification records
  - [x] 2.4: UPDATE policy: Editors/Owners can update verification decisions
  - [x] 2.5: DELETE policy: Only Owners can delete verifications
  - [x] 2.6: Add table and column comments

- [x] Task 3: Create Pydantic Models (AC: #1-5)
  - [x] 3.1: Create `backend/app/models/verification.py`
  - [x] 3.2: Add `VerificationDecision` enum: PENDING, APPROVED, REJECTED, FLAGGED
  - [x] 3.3: Add `VerificationRequirement` enum: OPTIONAL, SUGGESTED, REQUIRED
  - [x] 3.4: Add `FindingVerificationCreate` model (for new records)
  - [x] 3.5: Add `FindingVerificationUpdate` model (for attorney decisions)
  - [x] 3.6: Add `FindingVerification` model (full database record)
  - [x] 3.7: Add `VerificationQueueItem` model (for UI queue display)
  - [x] 3.8: Add `VerificationStats` model (for dashboard statistics)

- [x] Task 4: Create Verification Service (AC: #1-5)
  - [x] 4.1: Create `backend/app/services/verification/verification_service.py`
  - [x] 4.2: Implement `create_verification_record()` - called when finding is created
  - [x] 4.3: Implement `get_verification_requirement()` - returns OPTIONAL/SUGGESTED/REQUIRED based on confidence
  - [x] 4.4: Implement `record_verification_decision()` - attorney approval/rejection
  - [x] 4.5: Implement `get_pending_verifications()` - for queue UI
  - [x] 4.6: Implement `get_verification_stats()` - for dashboard
  - [x] 4.7: Implement `get_verification_by_finding()` - lookup by finding_id
  - [x] 4.8: Implement `bulk_update_verifications()` - for Story 8-5 queue UI

- [x] Task 5: Create Threshold Configuration (AC: #3-5)
  - [x] 5.1: Add `verification_threshold_optional` = 90.0 to `backend/app/core/config.py`
  - [x] 5.2: Add `verification_threshold_suggested` = 70.0 to config
  - [x] 5.3: Add `verification_export_block_below` = 70.0 (blocks export if unverified and below threshold)
  - [x] 5.4: Document thresholds in config comments per ADR-004

- [x] Task 6: Integrate with Engine Outputs (AC: #1)
  - [x] 6.1: Import VerificationService in `backend/app/engines/orchestrator/aggregator.py`
  - [x] 6.2: Added verification metadata calculation in aggregate_results
  - [x] 6.3: Include verification_requirement in finding response metadata
  - [x] 6.4: Added verification_metadata to OrchestratorResult model

- [x] Task 7: Create API Endpoints (AC: #1-5)
  - [x] 7.1: Create `backend/app/api/routes/verifications.py`
  - [x] 7.2: `GET /api/matters/{matter_id}/verifications` - list verifications for matter
  - [x] 7.3: `GET /api/matters/{matter_id}/verifications/pending` - pending queue
  - [x] 7.4: `GET /api/matters/{matter_id}/verifications/stats` - verification statistics
  - [x] 7.5: `POST /api/matters/{matter_id}/verifications/{verification_id}/approve` - approve finding
  - [x] 7.6: `POST /api/matters/{matter_id}/verifications/{verification_id}/reject` - reject finding
  - [x] 7.7: `POST /api/matters/{matter_id}/verifications/{verification_id}/flag` - flag for review
  - [x] 7.8: `POST /api/matters/{matter_id}/verifications/bulk` - bulk approve/reject

- [x] Task 8: Create Export Eligibility Check (AC: #5)
  - [x] 8.1: Create `backend/app/services/verification/export_eligibility.py`
  - [x] 8.2: Implement `check_export_eligibility()` - returns True/False + list of blocking findings
  - [x] 8.3: Implement `get_blocking_findings()` - findings < 70% without verification
  - [x] 8.4: Add export eligibility API endpoint for Story 12-3

- [x] Task 9: Create Unit Tests (AC: #1-5)
  - [x] 9.1: Create `backend/tests/services/verification/test_verification_service.py`
  - [x] 9.2: Test verification record creation on finding creation
  - [x] 9.3: Test confidence > 90% returns OPTIONAL requirement
  - [x] 9.4: Test confidence 70-90% returns SUGGESTED requirement
  - [x] 9.5: Test confidence < 70% returns REQUIRED requirement
  - [x] 9.6: Test verification decision recording
  - [x] 9.7: Test pending queue retrieval
  - [x] 9.8: Test bulk approval functionality

- [x] Task 10: Create Integration Tests (AC: #1-5)
  - [x] 10.1: Create `backend/tests/integration/test_verification_integration.py`
  - [x] 10.2: Test threshold boundary validation
  - [x] 10.3: Test verification queue prioritization
  - [x] 10.4: Test full workflow: create finding → create verification → approve → export check
  - [x] 10.5: Test export eligibility blocking for unverified low-confidence findings

- [x] Task 11: Update Module Exports
  - [x] 11.1: Update `backend/app/models/__init__.py` with verification exports
  - [x] 11.2: Create `backend/app/services/verification/__init__.py`
  - [x] 11.3: Register verifications router in `backend/app/main.py`
  - [x] 11.4: Update `backend/app/services/__init__.py` with verification exports

## Dev Notes

### Architecture Compliance

This story implements **Finding Verifications** - the attorney verification workflow for engine findings:

```
ENGINE OUTPUT → [LANGUAGE POLICING] → [VERIFICATION RECORD CREATED] → USER DISPLAY
                                              │
                                              ▼
                                    finding_verifications table
                                              │
                                              ▼
                              [ATTORNEY APPROVES/REJECTS/FLAGS]
                                              │
                                              ▼
                                      [EXPORT CHECK]
                                              │
                                 ┌────────────┴────────────┐
                                 │                         │
                          < 70% unverified          ≥ 70% or verified
                                 │                         │
                            BLOCK EXPORT              ALLOW EXPORT
```

This satisfies:
- **FR10**: Attorney Verification Workflow
- **NFR23**: Court-defensible verification workflow with forensic trail
- **ADR-004**: Verification Tier Thresholds (90%/70%)
- **Architecture**: Confidence thresholds for export (>70% required, >90% suggested)

### Critical Implementation Details

1. **Verification Thresholds (ADR-004)**

   Per architecture.md, the tiered verification system:

   | Confidence | In-App Display | Export Allowed | Verification |
   |------------|----------------|----------------|--------------|
   | >90%       | Show normally  | Yes            | Optional     |
   | 70-90%     | Show with badge| Warning shown  | Suggested    |
   | <70%       | Show with warning | Blocked     | Required     |

   ```python
   # Threshold constants
   VERIFICATION_THRESHOLD_OPTIONAL = 90.0  # > this = optional
   VERIFICATION_THRESHOLD_SUGGESTED = 70.0  # > this (and <= 90) = suggested
   # < 70.0 = required for export
   ```

2. **Table Schema Design**

   ```sql
   CREATE TABLE public.finding_verifications (
     id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
     matter_id uuid NOT NULL REFERENCES public.matters(id) ON DELETE CASCADE,
     finding_id uuid REFERENCES public.findings(id) ON DELETE SET NULL,
     -- Note: finding_id can be NULL if finding was deleted but verification kept for audit

     -- Finding snapshot (preserved even if finding deleted)
     finding_type text NOT NULL,
     finding_summary text NOT NULL,
     confidence_before float NOT NULL CHECK (confidence_before >= 0 AND confidence_before <= 100),

     -- Verification decision
     decision text NOT NULL DEFAULT 'pending'
       CHECK (decision IN ('pending', 'approved', 'rejected', 'flagged')),
     verified_by uuid REFERENCES auth.users(id),
     verified_at timestamptz,
     confidence_after float CHECK (confidence_after >= 0 AND confidence_after <= 100),
     notes text,

     -- Timestamps
     created_at timestamptz DEFAULT now(),
     updated_at timestamptz DEFAULT now()
   );
   ```

3. **Pydantic Models**

   ```python
   from enum import Enum
   from datetime import datetime
   from pydantic import BaseModel, Field

   class VerificationDecision(str, Enum):
       """Attorney verification decision.

       Story 8-4: Decision options for finding verification.
       """
       PENDING = "pending"
       APPROVED = "approved"
       REJECTED = "rejected"
       FLAGGED = "flagged"  # Needs further review

   class VerificationRequirement(str, Enum):
       """Verification requirement based on confidence.

       Story 8-4: Implements ADR-004 tiered verification.
       """
       OPTIONAL = "optional"      # Confidence > 90%
       SUGGESTED = "suggested"    # Confidence 70-90%
       REQUIRED = "required"      # Confidence < 70%

   class FindingVerificationCreate(BaseModel):
       """Create verification record when finding is generated.

       Story 8-4: AC #1 - Created automatically when finding generated.
       """
       matter_id: str = Field(..., description="Matter UUID")
       finding_id: str = Field(..., description="Finding UUID")
       finding_type: str = Field(..., description="Type: citation, timeline, contradiction")
       finding_summary: str = Field(..., description="Brief description for queue display")
       confidence_before: float = Field(..., ge=0, le=100, description="Confidence at creation")

   class FindingVerificationUpdate(BaseModel):
       """Update verification with attorney decision.

       Story 8-4: AC #2 - Attorney approval/rejection.
       """
       decision: VerificationDecision = Field(..., description="Attorney decision")
       confidence_after: float | None = Field(None, ge=0, le=100, description="Adjusted confidence")
       notes: str | None = Field(None, description="Attorney notes")

   class FindingVerification(BaseModel):
       """Complete verification record from database.

       Story 8-4: Full verification record with all fields.
       """
       id: str = Field(..., description="Verification UUID")
       matter_id: str = Field(..., description="Matter UUID")
       finding_id: str | None = Field(None, description="Finding UUID (nullable if deleted)")
       finding_type: str = Field(..., description="Finding type")
       finding_summary: str = Field(..., description="Finding summary")
       confidence_before: float = Field(..., description="Original confidence")
       decision: VerificationDecision = Field(..., description="Current decision")
       verified_by: str | None = Field(None, description="Verifier user UUID")
       verified_at: datetime | None = Field(None, description="Verification timestamp")
       confidence_after: float | None = Field(None, description="Adjusted confidence")
       notes: str | None = Field(None, description="Attorney notes")
       created_at: datetime = Field(..., description="Record creation")
       updated_at: datetime = Field(..., description="Last update")

       # Computed field
       verification_requirement: VerificationRequirement = Field(
           ..., description="Required/Suggested/Optional based on confidence"
       )

   class VerificationQueueItem(BaseModel):
       """Item in verification queue for UI.

       Story 8-4: Optimized for queue display, includes finding context.
       """
       id: str = Field(..., description="Verification UUID")
       finding_id: str | None = Field(None, description="Finding UUID")
       finding_type: str = Field(..., description="Finding type")
       finding_summary: str = Field(..., description="Summary for display")
       confidence: float = Field(..., description="Confidence percentage")
       requirement: VerificationRequirement = Field(..., description="Verification requirement")
       decision: VerificationDecision = Field(..., description="Current decision")
       created_at: datetime = Field(..., description="When finding was created")

       # Context for queue
       source_document: str | None = Field(None, description="Primary source document")
       engine: str = Field(..., description="Source engine")

   class VerificationStats(BaseModel):
       """Verification statistics for dashboard.

       Story 8-4: Aggregate stats for matter verification status.
       """
       total_verifications: int = Field(0, ge=0)
       pending_count: int = Field(0, ge=0)
       approved_count: int = Field(0, ge=0)
       rejected_count: int = Field(0, ge=0)
       flagged_count: int = Field(0, ge=0)

       # By requirement
       required_pending: int = Field(0, ge=0, description="< 70% confidence, pending")
       suggested_pending: int = Field(0, ge=0, description="70-90% confidence, pending")
       optional_pending: int = Field(0, ge=0, description="> 90% confidence, pending")

       # Export eligibility
       export_blocked: bool = Field(False, description="Has blocking unverified findings")
       blocking_count: int = Field(0, ge=0, description="Count of export-blocking findings")
   ```

4. **Verification Service Pattern**

   Follow the existing service patterns from Stories 8-1 to 8-3:

   ```python
   import threading
   from datetime import datetime, UTC

   import structlog
   from supabase import Client

   from app.core.config import get_settings
   from app.models.verification import (
       FindingVerification,
       FindingVerificationCreate,
       FindingVerificationUpdate,
       VerificationDecision,
       VerificationRequirement,
       VerificationQueueItem,
       VerificationStats,
   )

   logger = structlog.get_logger(__name__)

   # Singleton instance
   _verification_service: "VerificationService | None" = None
   _lock = threading.Lock()


   class VerificationService:
       """Service for managing finding verifications.

       Story 8-4: Implements tiered verification per ADR-004.

       Example:
           >>> service = get_verification_service()
           >>> record = await service.create_verification_record(
           ...     create_data=FindingVerificationCreate(
           ...         matter_id="uuid",
           ...         finding_id="uuid",
           ...         finding_type="citation",
           ...         finding_summary="Section 138 citation mismatch",
           ...         confidence_before=85.0,
           ...     ),
           ...     supabase=supabase_client,
           ... )
       """

       def __init__(self) -> None:
           """Initialize verification service."""
           settings = get_settings()
           self._threshold_optional = settings.verification_threshold_optional
           self._threshold_suggested = settings.verification_threshold_suggested
           logger.info(
               "verification_service_initialized",
               threshold_optional=self._threshold_optional,
               threshold_suggested=self._threshold_suggested,
           )

       def get_verification_requirement(
           self, confidence: float
       ) -> VerificationRequirement:
           """Determine verification requirement based on confidence.

           Story 8-4: AC #3-5 - Tiered verification per ADR-004.

           Args:
               confidence: Finding confidence (0-100).

           Returns:
               OPTIONAL if > 90%, SUGGESTED if 70-90%, REQUIRED if < 70%.
           """
           if confidence > self._threshold_optional:
               return VerificationRequirement.OPTIONAL
           elif confidence > self._threshold_suggested:
               return VerificationRequirement.SUGGESTED
           else:
               return VerificationRequirement.REQUIRED

       async def create_verification_record(
           self,
           create_data: FindingVerificationCreate,
           supabase: Client,
       ) -> FindingVerification:
           """Create verification record when finding is generated.

           Story 8-4: AC #1 - Automatic record creation.

           Args:
               create_data: Finding data for verification.
               supabase: Supabase client.

           Returns:
               Created FindingVerification record.
           """
           requirement = self.get_verification_requirement(
               create_data.confidence_before
           )

           result = supabase.table("finding_verifications").insert({
               "matter_id": create_data.matter_id,
               "finding_id": create_data.finding_id,
               "finding_type": create_data.finding_type,
               "finding_summary": create_data.finding_summary,
               "confidence_before": create_data.confidence_before,
               "decision": VerificationDecision.PENDING.value,
           }).execute()

           record = result.data[0]

           logger.info(
               "verification_record_created",
               verification_id=record["id"],
               finding_id=create_data.finding_id,
               finding_type=create_data.finding_type,
               confidence=create_data.confidence_before,
               requirement=requirement.value,
           )

           return self._to_model(record)

       async def record_verification_decision(
           self,
           verification_id: str,
           update_data: FindingVerificationUpdate,
           verified_by: str,
           supabase: Client,
       ) -> FindingVerification:
           """Record attorney verification decision.

           Story 8-4: AC #2 - Attorney approval/rejection.

           Args:
               verification_id: UUID of verification record.
               update_data: Decision and notes.
               verified_by: UUID of verifying attorney.
               supabase: Supabase client.

           Returns:
               Updated FindingVerification record.
           """
           update_fields = {
               "decision": update_data.decision.value,
               "verified_by": verified_by,
               "verified_at": datetime.now(UTC).isoformat(),
           }

           if update_data.confidence_after is not None:
               update_fields["confidence_after"] = update_data.confidence_after
           if update_data.notes is not None:
               update_fields["notes"] = update_data.notes

           result = supabase.table("finding_verifications").update(
               update_fields
           ).eq("id", verification_id).execute()

           record = result.data[0]

           logger.info(
               "verification_decision_recorded",
               verification_id=verification_id,
               decision=update_data.decision.value,
               verified_by=verified_by,
           )

           return self._to_model(record)

       async def get_pending_verifications(
           self,
           matter_id: str,
           supabase: Client,
           limit: int = 50,
       ) -> list[VerificationQueueItem]:
           """Get pending verifications for queue UI.

           Story 8-4: For Story 8-5 verification queue display.

           Args:
               matter_id: Matter UUID.
               supabase: Supabase client.
               limit: Max items to return.

           Returns:
               List of VerificationQueueItem for UI display.
           """
           result = supabase.table("finding_verifications").select(
               "*"
           ).eq("matter_id", matter_id).eq(
               "decision", VerificationDecision.PENDING.value
           ).order("created_at", desc=False).limit(limit).execute()

           return [self._to_queue_item(r) for r in result.data]

       async def get_verification_stats(
           self,
           matter_id: str,
           supabase: Client,
       ) -> VerificationStats:
           """Get verification statistics for dashboard.

           Story 8-4: Aggregate stats for matter.

           Args:
               matter_id: Matter UUID.
               supabase: Supabase client.

           Returns:
               VerificationStats with counts and export status.
           """
           result = supabase.table("finding_verifications").select(
               "*"
           ).eq("matter_id", matter_id).execute()

           records = result.data

           stats = VerificationStats()
           stats.total_verifications = len(records)

           for r in records:
               decision = r["decision"]
               confidence = r["confidence_before"]

               if decision == "pending":
                   stats.pending_count += 1
                   requirement = self.get_verification_requirement(confidence)
                   if requirement == VerificationRequirement.REQUIRED:
                       stats.required_pending += 1
                       stats.blocking_count += 1
                   elif requirement == VerificationRequirement.SUGGESTED:
                       stats.suggested_pending += 1
                   else:
                       stats.optional_pending += 1
               elif decision == "approved":
                   stats.approved_count += 1
               elif decision == "rejected":
                   stats.rejected_count += 1
               elif decision == "flagged":
                   stats.flagged_count += 1

           stats.export_blocked = stats.blocking_count > 0

           return stats

       def _to_model(self, record: dict) -> FindingVerification:
           """Convert database record to Pydantic model."""
           return FindingVerification(
               id=record["id"],
               matter_id=record["matter_id"],
               finding_id=record.get("finding_id"),
               finding_type=record["finding_type"],
               finding_summary=record["finding_summary"],
               confidence_before=record["confidence_before"],
               decision=VerificationDecision(record["decision"]),
               verified_by=record.get("verified_by"),
               verified_at=record.get("verified_at"),
               confidence_after=record.get("confidence_after"),
               notes=record.get("notes"),
               created_at=record["created_at"],
               updated_at=record["updated_at"],
               verification_requirement=self.get_verification_requirement(
                   record["confidence_before"]
               ),
           )

       def _to_queue_item(self, record: dict) -> VerificationQueueItem:
           """Convert to queue item for UI."""
           return VerificationQueueItem(
               id=record["id"],
               finding_id=record.get("finding_id"),
               finding_type=record["finding_type"],
               finding_summary=record["finding_summary"],
               confidence=record["confidence_before"],
               requirement=self.get_verification_requirement(
                   record["confidence_before"]
               ),
               decision=VerificationDecision(record["decision"]),
               created_at=record["created_at"],
               source_document=None,  # Would join with findings table
               engine=record["finding_type"].split("_")[0],  # Extract engine from type
           )


   def get_verification_service() -> VerificationService:
       """Get singleton VerificationService instance.

       Story 8-4: Thread-safe singleton factory.
       """
       global _verification_service  # noqa: PLW0603

       if _verification_service is None:
           with _lock:
               if _verification_service is None:
                   _verification_service = VerificationService()

       return _verification_service
   ```

5. **Integration with ResultAggregator**

   ```python
   # In aggregator.py - after finding creation
   async def aggregate_results_async(
       self,
       engine_results: list[EngineResult],
       intent: IntentAnalysisResult,
       matter_id: str,
       supabase: Client,
   ) -> OrchestratorResult:
       """Aggregate engine results with verification tracking.

       Story 6-2: Result aggregation.
       Story 8-3: Language policing.
       Story 8-4: Verification record creation.
       """
       # ... existing aggregation and policing logic ...

       # Story 8-4: Create verification records for each finding
       for finding in findings:
           await self._verification_service.create_verification_record(
               FindingVerificationCreate(
                   matter_id=matter_id,
                   finding_id=finding.id,
                   finding_type=finding.type,
                   finding_summary=finding.summary[:200],  # Truncate for queue
                   confidence_before=finding.confidence * 100,  # Convert 0-1 to 0-100
               ),
               supabase=supabase,
           )

       # Include verification requirement in response
       return OrchestratorResult(
           # ... other fields ...
           verification_metadata={
               "findings_count": len(findings),
               "required_verifications": sum(
                   1 for f in findings if f.confidence < 0.7
               ),
               "suggested_verifications": sum(
                   1 for f in findings if 0.7 <= f.confidence <= 0.9
               ),
           },
       )
   ```

6. **API Endpoints**

   ```python
   from fastapi import APIRouter, Depends, HTTPException

   from app.api.deps import get_current_user, get_supabase
   from app.models.verification import (
       FindingVerification,
       FindingVerificationUpdate,
       VerificationDecision,
       VerificationQueueItem,
       VerificationStats,
   )
   from app.services.verification import get_verification_service

   router = APIRouter(prefix="/verifications", tags=["verifications"])


   @router.get("/{matter_id}", response_model=list[FindingVerification])
   async def list_verifications(
       matter_id: str,
       decision: VerificationDecision | None = None,
       supabase = Depends(get_supabase),
       current_user = Depends(get_current_user),
   ) -> list[FindingVerification]:
       """List verification records for a matter.

       Story 8-4: API for verification listing.
       """
       service = get_verification_service()
       return await service.list_verifications(matter_id, decision, supabase)


   @router.get("/{matter_id}/pending", response_model=list[VerificationQueueItem])
   async def get_pending_queue(
       matter_id: str,
       limit: int = 50,
       supabase = Depends(get_supabase),
       current_user = Depends(get_current_user),
   ) -> list[VerificationQueueItem]:
       """Get pending verification queue for UI.

       Story 8-4: For Story 8-5 verification queue UI.
       """
       service = get_verification_service()
       return await service.get_pending_verifications(matter_id, supabase, limit)


   @router.get("/{matter_id}/stats", response_model=VerificationStats)
   async def get_stats(
       matter_id: str,
       supabase = Depends(get_supabase),
       current_user = Depends(get_current_user),
   ) -> VerificationStats:
       """Get verification statistics for dashboard.

       Story 8-4: Stats for verification dashboard.
       """
       service = get_verification_service()
       return await service.get_verification_stats(matter_id, supabase)


   @router.post("/{verification_id}/approve", response_model=FindingVerification)
   async def approve_verification(
       verification_id: str,
       notes: str | None = None,
       confidence_after: float | None = None,
       supabase = Depends(get_supabase),
       current_user = Depends(get_current_user),
   ) -> FindingVerification:
       """Approve a finding verification.

       Story 8-4: AC #2 - Attorney approval.
       """
       service = get_verification_service()
       return await service.record_verification_decision(
           verification_id,
           FindingVerificationUpdate(
               decision=VerificationDecision.APPROVED,
               notes=notes,
               confidence_after=confidence_after,
           ),
           verified_by=current_user.id,
           supabase=supabase,
       )


   @router.post("/{verification_id}/reject", response_model=FindingVerification)
   async def reject_verification(
       verification_id: str,
       notes: str,  # Required for rejections
       supabase = Depends(get_supabase),
       current_user = Depends(get_current_user),
   ) -> FindingVerification:
       """Reject a finding verification.

       Story 8-4: AC #2 - Attorney rejection.
       """
       service = get_verification_service()
       return await service.record_verification_decision(
           verification_id,
           FindingVerificationUpdate(
               decision=VerificationDecision.REJECTED,
               notes=notes,
           ),
           verified_by=current_user.id,
           supabase=supabase,
       )
   ```

### Existing Code to Reuse (DO NOT REINVENT)

| Component | Location | Purpose |
|-----------|----------|---------|
| `findings` table | `supabase/migrations/20260106000004_*` | Existing findings table to reference |
| `KeyFinding` model | `models/memory.py` | Finding model pattern with verification |
| `FindingType` enum | `models/memory.py` | Finding type definitions |
| `LanguagePolice` | `services/safety/language_police.py` | Integration point for policing |
| `ResultAggregator` | `engines/orchestrator/aggregator.py` | Integration point for verification |
| `get_settings()` | `core/config.py` | Configuration access pattern |
| `structlog` | All modules | Structured logging |
| `matter_attorneys` RLS | All migrations | RLS policy pattern |

### Previous Story (8-3) Learnings

From Story 8-3 implementation and code review:

1. **Singleton Factory Pattern**: Use `threading.Lock()` for thread-safe initialization
2. **Timing Metrics**: Use `time.perf_counter()` for performance tracking
3. **Story References**: Include Story reference in all docstrings
4. **Configuration**: Add feature flags for enabling/disabling features
5. **Fail Graceful**: Service failures should not break main workflow
6. **Global Statement**: Use `# noqa: PLW0603` for global variable assignments

### Git Intelligence

Recent commit patterns:
- `feat(safety): implement language policing output sanitization (Story 8-3)`
- `fix(review): code review fixes for Story 8-3`
- `feat(safety): implement GPT-4o-mini subtle violation detection (Story 8-2)`

Use: `feat(safety): implement finding verifications table (Story 8-4)`

### File Structure

```
supabase/migrations/
└── YYYYMMDD_create_finding_verifications_table.sql  # NEW: Migration

backend/app/
├── core/
│   └── config.py                     # UPDATE: Add verification thresholds
├── models/
│   ├── __init__.py                   # UPDATE: Add verification exports
│   └── verification.py               # NEW: Verification models
├── services/
│   └── verification/
│       ├── __init__.py               # NEW: Module init
│       ├── verification_service.py   # NEW: Main service
│       └── export_eligibility.py     # NEW: Export check
├── api/
│   └── routes/
│       ├── __init__.py               # UPDATE: Add router
│       └── verifications.py          # NEW: API endpoints
└── engines/
    └── orchestrator/
        └── aggregator.py             # UPDATE: Integrate verification

backend/tests/
├── services/
│   └── verification/
│       ├── __init__.py               # NEW
│       └── test_verification_service.py  # NEW: Unit tests
└── api/
    └── test_verifications.py         # NEW: API tests
```

### Testing Requirements

Per project-context.md:
- Backend: Separate test directory structure
- Use pytest-asyncio for async tests
- Mock Supabase client for unit tests
- Include matter isolation verification tests

**Minimum Test Cases:**

```python
# test_verification_service.py

import pytest
from unittest.mock import AsyncMock, MagicMock

from app.models.verification import (
    FindingVerificationCreate,
    FindingVerificationUpdate,
    VerificationDecision,
    VerificationRequirement,
)
from app.services.verification import VerificationService


class TestVerificationRequirement:
    """Test confidence threshold logic."""

    def test_above_90_is_optional(self, service):
        """Confidence > 90% = OPTIONAL verification."""
        assert service.get_verification_requirement(95.0) == VerificationRequirement.OPTIONAL
        assert service.get_verification_requirement(91.0) == VerificationRequirement.OPTIONAL

    def test_70_to_90_is_suggested(self, service):
        """Confidence 70-90% = SUGGESTED verification."""
        assert service.get_verification_requirement(85.0) == VerificationRequirement.SUGGESTED
        assert service.get_verification_requirement(70.1) == VerificationRequirement.SUGGESTED

    def test_below_70_is_required(self, service):
        """Confidence < 70% = REQUIRED verification."""
        assert service.get_verification_requirement(65.0) == VerificationRequirement.REQUIRED
        assert service.get_verification_requirement(50.0) == VerificationRequirement.REQUIRED
        assert service.get_verification_requirement(0.0) == VerificationRequirement.REQUIRED

    def test_boundary_at_90(self, service):
        """Exactly 90% = SUGGESTED (not > 90)."""
        assert service.get_verification_requirement(90.0) == VerificationRequirement.SUGGESTED

    def test_boundary_at_70(self, service):
        """Exactly 70% = REQUIRED (not > 70)."""
        assert service.get_verification_requirement(70.0) == VerificationRequirement.REQUIRED


@pytest.mark.asyncio
class TestVerificationRecordCreation:
    """Test verification record creation."""

    async def test_creates_record_on_finding(self, service, mock_supabase):
        """Verification record created when finding generated."""
        mock_supabase.table().insert().execute.return_value = MagicMock(
            data=[{
                "id": "verification-uuid",
                "matter_id": "matter-uuid",
                "finding_id": "finding-uuid",
                "finding_type": "citation_mismatch",
                "finding_summary": "Section 138 mismatch",
                "confidence_before": 85.0,
                "decision": "pending",
                "created_at": "2026-01-14T00:00:00Z",
                "updated_at": "2026-01-14T00:00:00Z",
            }]
        )

        result = await service.create_verification_record(
            FindingVerificationCreate(
                matter_id="matter-uuid",
                finding_id="finding-uuid",
                finding_type="citation_mismatch",
                finding_summary="Section 138 mismatch",
                confidence_before=85.0,
            ),
            supabase=mock_supabase,
        )

        assert result.id == "verification-uuid"
        assert result.decision == VerificationDecision.PENDING
        assert result.verification_requirement == VerificationRequirement.SUGGESTED


@pytest.mark.asyncio
class TestVerificationDecision:
    """Test attorney verification decisions."""

    async def test_approve_updates_record(self, service, mock_supabase):
        """Approval updates decision and verified_by."""
        mock_supabase.table().update().eq().execute.return_value = MagicMock(
            data=[{
                "id": "verification-uuid",
                "matter_id": "matter-uuid",
                "finding_id": "finding-uuid",
                "finding_type": "citation_mismatch",
                "finding_summary": "Section 138 mismatch",
                "confidence_before": 85.0,
                "decision": "approved",
                "verified_by": "attorney-uuid",
                "verified_at": "2026-01-14T00:00:00Z",
                "created_at": "2026-01-14T00:00:00Z",
                "updated_at": "2026-01-14T00:00:00Z",
            }]
        )

        result = await service.record_verification_decision(
            "verification-uuid",
            FindingVerificationUpdate(decision=VerificationDecision.APPROVED),
            verified_by="attorney-uuid",
            supabase=mock_supabase,
        )

        assert result.decision == VerificationDecision.APPROVED
        assert result.verified_by == "attorney-uuid"

    async def test_reject_requires_notes(self, service, mock_supabase):
        """Rejection should include notes."""
        mock_supabase.table().update().eq().execute.return_value = MagicMock(
            data=[{
                "id": "verification-uuid",
                "matter_id": "matter-uuid",
                "finding_type": "citation_mismatch",
                "finding_summary": "Section 138 mismatch",
                "confidence_before": 85.0,
                "decision": "rejected",
                "notes": "Citation was correct, finding was false positive",
                "verified_by": "attorney-uuid",
                "verified_at": "2026-01-14T00:00:00Z",
                "created_at": "2026-01-14T00:00:00Z",
                "updated_at": "2026-01-14T00:00:00Z",
            }]
        )

        result = await service.record_verification_decision(
            "verification-uuid",
            FindingVerificationUpdate(
                decision=VerificationDecision.REJECTED,
                notes="Citation was correct, finding was false positive",
            ),
            verified_by="attorney-uuid",
            supabase=mock_supabase,
        )

        assert result.decision == VerificationDecision.REJECTED
        assert result.notes is not None


@pytest.mark.asyncio
class TestExportEligibility:
    """Test export blocking for unverified findings."""

    async def test_blocks_export_with_required_pending(self, service, mock_supabase):
        """Export blocked when < 70% confidence findings unverified."""
        mock_supabase.table().select().eq().execute.return_value = MagicMock(
            data=[
                {"confidence_before": 50.0, "decision": "pending"},  # Blocking
                {"confidence_before": 85.0, "decision": "approved"},
            ]
        )

        stats = await service.get_verification_stats("matter-uuid", mock_supabase)

        assert stats.export_blocked is True
        assert stats.blocking_count == 1

    async def test_allows_export_when_all_verified(self, service, mock_supabase):
        """Export allowed when all required findings verified."""
        mock_supabase.table().select().eq().execute.return_value = MagicMock(
            data=[
                {"confidence_before": 50.0, "decision": "approved"},  # Was required, now approved
                {"confidence_before": 85.0, "decision": "pending"},   # Only suggested
            ]
        )

        stats = await service.get_verification_stats("matter-uuid", mock_supabase)

        assert stats.export_blocked is False
        assert stats.blocking_count == 0
```

### Security Considerations

1. **Matter Isolation**: RLS policies ensure verifications are matter-scoped
2. **Audit Trail**: All verification decisions logged with timestamp and user
3. **Export Control**: Block export of unverified low-confidence findings
4. **Role Enforcement**: Only Editors/Owners can create/update verifications

### Integration Points

1. **ResultAggregator (Epic 6)**: Creates verification records after finding generation
2. **Story 8-3**: Language policing runs before verification records created
3. **Story 8-5**: Verification queue UI consumes `get_pending_verifications()`
4. **Story 12-3**: Export API uses `check_export_eligibility()`

### Dependencies

This story depends on:
- **Story 8-3**: Language policing (DONE)
- **Epic 6**: Engine orchestrator (DONE)
- **Findings table**: Existing migration (DONE)

This story blocks:
- **Story 8-5**: Verification Queue UI

### Critical NFR Compliance

**NFR23: Court-defensible verification workflow with forensic trail**

To achieve court-defensible verification:
1. Every finding automatically gets verification record
2. All attorney decisions timestamped with user ID
3. Confidence scores preserved (before and after verification)
4. Notes field captures attorney reasoning
5. Export blocked for unverified low-confidence findings

### Project Structure Notes

- New migration file for `finding_verifications` table
- New `services/verification/` directory for verification service
- New `api/routes/verifications.py` for API endpoints
- Extend `core/config.py` with threshold settings

### References

- [Project Context](_bmad-output/project-context.md) - Naming conventions, testing rules
- [Architecture: ADR-004](_bmad-output/architecture.md#adr-004-verification-tier-thresholds) - Tiered verification
- [Architecture: Safety Layer](_bmad-output/architecture.md#safety-layer-mandatory) - Safety requirements
- [Story 8-3: Language Policing](8-3-language-policing.md) - Integration point
- [FR10 Requirement](_bmad-output/project-planning-artifacts/epics.md) - Attorney Verification
- [NFR23 Requirement](_bmad-output/project-planning-artifacts/epics.md) - Court-defensible trail
- [Findings Migration](supabase/migrations/20260106000004_create_findings_table.sql) - Existing findings table

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

N/A - Implementation completed successfully with 34/34 tests passing.

### Completion Notes List

1. All 11 tasks completed successfully
2. 34 tests passing (unit + integration)
3. Database migration created with complete RLS policies
4. Verification service implements ADR-004 tiered thresholds (>90% optional, 70-90% suggested, <70% required)
5. Export eligibility service blocks export for unverified findings below 70% confidence
6. API endpoints follow existing patterns with matter_id path parameter
7. Integration with ResultAggregator adds verification_metadata to orchestrator results
8. Pydantic models include field validation (max_length for summaries, ge/le for confidence)

### File List

**NEW FILES:**
- `supabase/migrations/20260114000009_create_finding_verifications_table.sql` - Database migration with RLS
- `backend/app/models/verification.py` - Pydantic models for verification
- `backend/app/services/verification/__init__.py` - Service module exports
- `backend/app/services/verification/verification_service.py` - Main verification service
- `backend/app/services/verification/export_eligibility.py` - Export eligibility check
- `backend/app/api/routes/verifications.py` - API endpoints
- `backend/tests/services/verification/__init__.py` - Test module init
- `backend/tests/services/verification/test_verification_service.py` - Unit tests
- `backend/tests/services/verification/test_export_eligibility.py` - Export service tests
- `backend/tests/integration/test_verification_integration.py` - Integration tests

**MODIFIED FILES:**
- `backend/app/core/config.py` - Added verification threshold settings
- `backend/app/models/__init__.py` - Added verification model exports
- `backend/app/models/orchestrator.py` - Added verification_metadata field
- `backend/app/engines/orchestrator/aggregator.py` - Added verification metadata calculation
- `backend/app/services/__init__.py` - Added verification service exports
- `backend/app/main.py` - Registered verifications router

